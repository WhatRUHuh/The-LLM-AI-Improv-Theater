# 设计思路 - “一个服务商支持多个命名API Key”功能

## 1. 功能概述

### 1.1. 目标
实现允许用户为同一个AI服务商（例如Google、OpenAI等）配置和管理多个带有自定义名称的API Key。

### 1.2. 用户价值
*   **灵活性增强：** 用户可以为不同的项目、目的或账户使用不同的API Key，方便区分和管理。
*   **便捷性提升：** 用户可以给每个API Key起一个易于识别的名称，例如“个人测试Key”、“项目A专用Key”，避免混淆。
*   **管理简化：** 集中管理所有服务商的API Key，方便切换和维护。
*   **成本控制（潜在）：** 某些服务商可能对不同Key有不同的计费或配额，此功能便于用户按需使用。

## 2. 数据结构变更

### 2.1. `AIConfig` 接口/类型定义
为了支持多Key管理，我们引入了新的核心数据结构 `AIConfig`，其主要字段定义如下（位于 `src/types/index.ts`）：

```typescript
interface AIConfig {
  id: string; // 唯一标识符，通常使用UUID
  serviceProvider: string; // 服务商ID (例如 "google", "openai")
  apiKey: string; // 该服务商的API Key
  name: string; // 用户自定义的Key名称 (例如 "我的Gemini Key")
  baseURL?: string; // 可选，针对某些需要自定义API接入点的服务商
  // 其他可能需要的配置项...
}
```
*   `id`: 每个API Key配置的唯一ID，用于精确引用。
*   `serviceProvider`: 关联的服务商。
*   `apiKey`: 实际的API密钥。
*   `name`: 用户为这个Key配置起的名字，方便识别。

### 2.2. 持久化存储 - `aiConfigurations.json`
所有 `AIConfig` 对象将以数组的形式 (`AIConfig[]`) 持久化存储在用户本地的 `aiConfigurations.json` 文件中。该文件由 `electron/storage/jsonStore.ts` 负责管理。

路径示例：用户应用数据目录下的 `aiConfigurations.json`。

### 2.3. `ChatConfig` 中 `aiConfigs` 的统一数据结构
为了在各个聊天模式的设置页面和聊天界面之间统一传递和使用AI配置信息，我们将 `ChatConfig`（通常作为路由状态传递）中的 `aiConfigs` 字段统一为以下结构：

```typescript
// 位于 src/types/index.ts 或相关页面类型定义中
interface ChatAIConfig {
  configId: string;     // 选定的 AIConfig 的 id
  modelName: string;    // 选定的模型名称 (例如 "gemini-pro", "gpt-3.5-turbo")
  providerId: string;   // 选定的服务商 ID (例如 "google", "openai")
}

// ChatConfig.aiConfigs 的结构
// 对于单人单AI模式，只有一个角色，通常用一个固定的key（如 'user' 或 'default'）
// 对于单人多AI或导演模式，key是角色ID
aiConfigs: Record<string, ChatAIConfig>;
```
*   **`Record<角色ID, ChatAIConfig>`**:
    *   `key` (字符串): 代表角色的唯一ID。在单人单AI模式下，可以是一个固定的标识符（如 "defaultUser"）。在多AI或导演模式下，是每个参与对话的AI角色的ID。
    *   `value` (`ChatAIConfig`):
        *   `configId`: 指向 `aiConfigurations.json` 中某个 `AIConfig` 的 `id`。这决定了使用哪个API Key。
        *   `modelName`: 在该 `configId` 对应的服务商下选定的具体模型。
        *   `providerId`: 该 `configId` 对应的服务商ID，用于冗余校验和方便查找。

这个统一的数据结构确保了无论在哪种聊天模式下，聊天界面都能清晰地知道每个角色应该使用哪个服务商的哪个命名API Key下的哪个模型。

## 3. 主要模块的职责和交互调整

### 3.1. `electron/storage/jsonStore.ts` - AI配置的持久化管理
`jsonStore.ts` 扩展了其能力，专门负责 `AIConfig` 对象的增、删、改、查操作：

*   **`getAllAIConfigs(): Promise<AIConfig[]>`**: 读取并返回 `aiConfigurations.json` 中的所有AI配置。
*   **`addAIConfig(config: Omit<AIConfig, 'id'>): Promise<AIConfig>`**: 添加一个新的AI配置。内部会自动生成 `id`，然后保存到文件中。
*   **`updateAIConfig(configId: string, updates: Partial<Omit<AIConfig, 'id'>>): Promise<AIConfig | null>`**: 根据 `configId` 更新一个已有的AI配置。
*   **`deleteAIConfig(configId: string): Promise<boolean>`**: 根据 `configId` 删除一个AI配置。
*   **`getAIConfigById(configId: string): Promise<AIConfig | null>`**: 根据 `configId` 获取单个AI配置的详细信息。

这些方法通过IPC通道暴露给渲染进程使用。

### 3.2. `src/pages/AIConfigPage.tsx` - 多Key配置的UI与逻辑
AI配置页面 (`AIConfigPage.tsx`) 是用户管理多个命名API Key的核心界面，其主要功能和实现逻辑包括：

*   **UI展示：**
    *   以列表或卡片形式清晰展示所有已配置的 `AIConfig`，包括其名称、服务商、部分掩码的API Key等。
    *   按服务商对配置进行分组展示，方便用户查找。
*   **新配置添加入口：**
    *   提供一个全局的、始终可见的“添加新配置”或“+”按钮，确保用户在任何情况下（即使当前没有任何配置）都能方便地找到添加入口。
    *   点击添加后，弹出模态框或跳转到新页面，让用户选择服务商、填写API Key、自定义名称等信息。
*   **已有配置的选择与高亮：**
    *   （如果适用，例如在某个流程中需要选择一个配置）允许用户点击选择某个配置，并给予视觉反馈。
*   **编辑逻辑：**
    *   每个已配置的Key旁边提供“编辑”按钮。
    *   点击编辑，允许用户修改该Key的名称、API Key值（通常需要重新输入以确认）、Base URL等。`serviceProvider` 和 `id` 通常不可修改。
*   **删除逻辑：**
    *   每个已配置的Key旁边提供“删除”按钮。
    *   点击删除，通常会有二次确认提示，防止误操作。
    *   确认后，调用后端IPC删除该配置，并更新UI列表。
*   **数据同步：** 页面加载时通过IPC获取所有AI配置，并在增删改操作后刷新列表。

### 3.3. `electron/llm/LLMServiceManager.ts` - 基于Config ID的服务实例与模型管理
`LLMServiceManager.ts` 的核心职责调整为基于 `configId` 来管理和提供LLM服务实例及模型列表：

*   **`getInstance(configId: string): Promise<BaseLLM | null>`**:
    *   这是获取LLM服务实例的核心方法。
    *   它首先通过 `jsonStore.getAIConfigById(configId)` 获取到 `AIConfig` 的详细信息（包括 `apiKey`, `serviceProvider`, `baseURL` 等）。
    *   然后根据 `serviceProvider` 动态创建对应的LLM服务类实例（如 `Google`, `OpenAI`），并将 `apiKey` 和 `baseURL` 等配置传入。
    *   缓存已创建的实例以提高效率，但要注意当 `AIConfig` 更新后，需要使缓存失效或更新实例。
*   **`getAvailableModels(configId: string): Promise<string[]>`**:
    *   通过 `getInstance(configId)` 获取到服务实例。
    *   调用该实例的 `listModels()` 方法，返回该API Key下可用的模型列表。
*   **`getSupportedServiceProviders(): Promise<{id: string, name: string}[]>`**:
    *   返回一个列表，包含当前系统支持的所有服务商及其ID和显示名称（例如 `{id: "google", name: "Google"}`）。这个列表通常是硬编码或通过某种配置方式定义的。
*   **数据获取：** 内部会通过 `jsonStore` 获取必要的 `AIConfig` 数据。

### 3.4. 各设置页面 (`SingleUserSingleAISetupPage.tsx`, `SingleUserMultiAISetupPage.tsx`, `DirectorModeSetupPage.tsx`) - 三级联动选择与数据组织
所有涉及AI选择的设置页面都实现了“服务商 -> 命名Key -> 模型”的三级联动选择逻辑：

1.  **第一级 - 选择服务商：**
    *   用户首先从下拉列表或选项中选择一个AI服务商（例如 "Google"）。数据源是 `LLMServiceManager.getSupportedServiceProviders()`。
2.  **第二级 - 选择命名Key：**
    *   当服务商选定后，页面会通过IPC调用（例如，一个新的IPC `'get-ai-configs-by-provider-id'`，或者前端过滤 `getAllAIConfigs()` 的结果）获取该服务商下所有已配置的 `AIConfig`。
    *   用户从这些命名Key中选择一个（例如 "我的Gemini Key"）。列表中应清晰显示 `AIConfig` 的 `name` 字段。
    *   如果该服务商下没有任何已配置的Key，应提示用户前往 `AIConfigPage.tsx` 添加，或者提供一个快捷入口。
3.  **第三级 - 选择模型：**
    *   当命名Key（即 `configId`）选定后，页面会通过IPC调用 `LLMServiceManager.getAvailableModels(configId)` 获取该Key下可用的模型列表。
    *   用户从这些模型中选择一个（例如 "gemini-pro"）。
4.  **数据组织与传递：**
    *   完成选择后，设置页面会将选定的 `configId` (来自第二级选择的 `AIConfig.id`)、`modelName` (来自第三级选择) 和 `providerId` (来自第一级选择的服务商ID) 组织成前述的 `ChatAIConfig` 结构。
    *   对于多角色场景（如导演模式），会为每个需要配置AI的角色重复此三级选择流程，并将结果存入 `aiConfigs: Record<角色ID, ChatAIConfig>` 对象中。
    *   最终，这个包含 `aiConfigs` 的 `ChatConfig` 对象会通过路由状态或其他方式传递给对应的聊天界面。
    *   **配置回填：** 当用户再次进入设置页面时，需要能根据之前保存的 `configId`, `modelName`, `providerId` 正确回填并高亮显示已选的选项。

### 3.5. 各聊天界面 (`SingleUserSingleAIInterfacePage.tsx`, `SingleUserMultiAIInterfacePage.tsx`, `DirectorModeInterfacePage.tsx`) - 使用统一配置进行API调用
聊天界面接收到包含 `aiConfigs` 的 `ChatConfig` 后，其核心逻辑是根据这些信息正确地进行API调用：

*   **获取配置：** 从传入的 `chatConfig.aiConfigs` 中，根据当前需要发言的角色ID，提取出对应的 `ChatAIConfig` 对象，从而得到 `configId`, `modelName`, `providerId`。
*   **API调用：**
    *   在实际发起LLM请求时，将 `configId` 和 `modelName` (以及其他聊天参数如 `prompt`, `history` 等) 通过IPC传递给后端的 `LLMServiceManager` 的某个统一处理方法（例如，一个名为 `'send-chat-message'` 的IPC通道，其参数包含 `configId`, `modelName`, `messages` 等）。
    *   `LLMServiceManager` 内部会使用 `getInstance(configId)` 获取LLM服务实例，然后调用该实例的聊天方法（如 `chat()` 或 `generateContent()`），并传入 `modelName` 和消息体。
*   **确保正确性：** 关键在于确保从 `aiConfigs` 中为正确的角色取出了正确的 `configId` 和 `modelName`，并将其无误地传递到后端进行处理。

## 4. IPC通信变更
为了支持新功能，引入和调整了以下关键的IPC通道（定义在 `electron/ipcHandlers.ts` 和 `electron/preload.ts`）：

*   **新增/核心IPC：**
    *   `'get-all-ai-configs'`: 渲染进程请求获取所有已配置的 `AIConfig`。由 `jsonStore.getAllAIConfigs()` 处理。
    *   `'add-ai-config'`: 渲染进程请求添加一个新的 `AIConfig`。由 `jsonStore.addAIConfig()` 处理。
    *   `'update-ai-config'`: 渲染进程请求更新一个已有的 `AIConfig`。由 `jsonStore.updateAIConfig()` 处理。
    *   `'delete-ai-config'`: 渲染进程请求删除一个 `AIConfig`。由 `jsonStore.deleteAIConfig()` 处理。
    *   `'get-ai-config-by-id'`: 渲染进程请求获取单个 `AIConfig` 的详情。由 `jsonStore.getAIConfigById()` 处理。
    *   `'get-supported-service-providers'`: 渲染进程请求获取支持的服务商列表。由 `LLMServiceManager.getSupportedServiceProviders()` 处理。
    *   `'get-available-models-by-config-id'`: 渲染进程根据 `configId` 请求获取可用模型列表。由 `LLMServiceManager.getAvailableModels(configId)` 处理。
    *   `'send-chat-message'` (或类似名称): 渲染进程发送聊天请求，参数包含 `configId`, `modelName`, `messages` 等。由 `LLMServiceManager` 协调处理。
*   **废弃/替换的IPC：**
    *   旧的、不区分命名Key的获取服务/模型列表的IPC（例如，可能存在的 `'llm-get-services'` 或 `'llm-get-models-by-provider'`）被上述更精确的IPC取代。全局搜索并替换了 `'llm-get-services'` 为 `'get-all-ai-configs'` 或其等效逻辑。

## 5. 日志记录增强
日志系统 (`electron/utils/logger.ts` 或 `chatLoggerUtil.ts`) 进行了增强，以便在记录聊天交互或其他相关操作时，能够体现当前使用的AI配置信息：

*   在聊天日志中，除了记录用户输入、AI回复、时间戳等，还会记录当前对话所使用的 `AIConfig` 的 `name` 和 `id`，以及选定的 `modelName`。
*   例如，日志条目可能包含类似 `"Using AI: MyGeminiKey (configId: xxx-yyy-zzz) with model: gemini-pro"` 的信息。
*   这有助于在出现问题时，快速定位到是哪个API Key或模型配置可能存在问题。

## 6. 关键Bug修复历程 (简述)
在实现此功能的过程中，我们解决了一系列关键问题，确保了系统的稳定性和用户体验：

*   **设置页面无限循环：** 修复了在某些设置页面（尤其是单人单AI设置页）由于 `useEffect` 依赖项不当或状态更新逻辑错误导致的无限循环加载可用模型或AI配置的问题。通过优化依赖项数组、使用 `useCallback` 以及更精细的状态管理逻辑解决。
*   **聊天界面`configId`传递错误：** 确保了从设置页面到聊天界面，以及在聊天界面内部处理时，`configId` 能够被正确、统一地传递和使用。修正了之前可能存在的从 `localStorage` 或旧配置结构中错误读取 `configId` 的情况。
*   **AI配置页面无法添加新配置/UI更新不及时：** 解决了 `AIConfigPage.tsx` 中添加新配置后UI列表不刷新，或添加逻辑本身存在缺陷导致无法成功保存的问题。确保了IPC调用成功后状态能正确更新并触发UI重渲染。
*   **TypeScript编译错误：** 解决了因数据结构变更或代码重构引入的TypeScript类型错误，如属性不存在、隐式`any`等，增强了代码的健壮性。
*   **React Hooks依赖项警告：** 修正了多处 `useEffect` 和 `useCallback` 的 `exhaustive-deps` 警告，确保了Hooks的正确使用。

这些修复工作与新功能的开发齐头并进，共同提升了应用的整体质量。

## 7. 总结与展望
“一个服务商支持多个命名API Key”功能的引入，是应用在灵活性、用户体验和可管理性方面的一次重要升级。它通过清晰的数据结构、模块化的服务管理以及流畅的UI交互，为用户提供了更强大、更便捷的AI配置能力。

未来的工作可以考虑：
*   API Key的有效性校验功能。
*   更细致的配额使用提示或统计。
*   支持更多AI服务商。

---
这份文档记录了本次功能迭代的核心设计与实现思路，希望能为后续的维护和新功能开发提供有力的参考。